# ----------------------------------------37강 객체와 리스트
# 함수에는 내장함수(print(), int() 등등)과 사용자정의함수(def a(a,b))가 있다.

# 객체 = 폴더(어떤 데이터를 묶을 때 사용) / 묶일 필요가 있는 데이터는 묶는 게 좋다.

# 리스트(객체 중 하나)

ages = [10, 20, 30]
# 변수에는 값을 하나밖에 담지 못함. 그러니까 변수에 객체를 담을 수는 없음
# 그러니 주소를 담는다 == 주소를 참조한다.

# 램은 스택과 힙으로 구성되어 있는데, 객체는 힙에 생성됨.

# 리스트의 길이는 무한정임

ages = []
ages2 = []
# 두 객체는 완전히 다른 것.

ages2 = ages
# ages 객체의 주소값을 age2에도 넣은 것
# 그렇다면 객체는 2개가 있지만, 기존의 ages2 객체의 주소는 잃어버려 더이상 못찾음.

ages.append(10)
ages2.append(10)

print(ages)  # == [10,10]


# ----------------------------------------38강 객체와 리스트
# 리스트 : 추가, 삭제, 수정

a = [1, 2, 3, 4]  # 리스트 초기화

a.append(4)  # 리스트에 값 추가 , 마지막에 추가됨

a.remove(4)  # 리스트의 특정값 1개 삭제, remove(value), 위치는 앞부터 차례대로 삭제됨

# a.index(1, 3)  # a = [1,3,2,3,4] # 특정 위치에 값 추가 함수, insert(index, value)

del a[1]  # a = [1,2,3,4] , del a[index], 특정 위치 값 삭제

a.index(4)  # 4라는 요소값의 위치를 알려주는 함수, a.index(value)

a[0] = 10  # 리스트값 수정, 0번째 값을 10으로 수정

len(a)  # 리스트의 길이, len(var)

a.sort()  # 리스트 정렬, 오름차순

a.reverse()  # 리스트 뒤집기

min(a)
max(a)
# min : 리스트 안에 최소값 출력
# max : 리스트 안에 최대값 출력
nums = [3, 1, 4, 1, 5, 9, 1, 6, 5, 3, 5]
print(f"최대값 : {max(nums)}")
print(f"최소값 : {min(nums)}")

nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
nums2.reverse()  # 리스트를 거꾸로 뒤집는 함수(원본 리스트를 훼손)
print(nums2)

# sorted : 리스트의 원본을 훼손하지 않고 뒤집은 후 정렬
rs = sorted(nums2, reverse=True)
# False를 넣으면 뒤집히지 않고 나옴(원본을 훼손하지 않고 복사본을 만든다.)
# True를 넣으면 뒤집히고 복사본 나옴.

print(rs)


# -----------------------------------44강, 리스트 슬라이싱

a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 슬라이싱 : 원본 리스트를 사용해서 복사본을 만든 후 반환시킨다.
rs = a[1:3]  # 1번째 인덱스에서 3번째 인덱스 전까지 기져온다.
print(rs)  # [2,3]


# 만약 시작 인덱스를 생략하면 기본값은 인덱스의 시작이다.
rs2 = a[:3]  # ==[1,2,3]

# 종료 인덱스-1 까지 출력해줌.

rs3 = a[1:5:2]  # ==[2,4] , 2씩 건너뛴다.
# 시작 인덱스 : 종료 인덱스  : 스텝]
# 슬라이싱할 때 몇 개의 요소를 건너뛸지 결정
# 스텝은 생략해도 된다.

rs4 = a[2:]  # == [3,4,5,6,7,~] 인덱스 2에서 끝까지 슬라이싱


rs5 = a[:]  #  전체 리스트를 슬라이싱 == 복사

rs6 = a[::-1]  # 전체 리스트를 역순으로 슬라이싱


